<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Session</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --secondary-color: #0ea5e9;
            --text-color: #1f2937;
            --text-muted: #6b7280;
            --light-bg: #f9fafb;
            --card-bg: #ffffff;
            --border-color: #e5e7eb;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-bg);
            color: var(--text-color);
            min-height: 100vh;
        }
        
        .session-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        
        .chat-container {
            height: calc(100vh - 250px);
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .message {
            margin-bottom: 1rem;
            max-width: 80%;
        }
        
        .message-moderator {
            margin-right: auto;
        }
        
        .message-participant {
            margin-left: auto;
        }
        
        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            display: inline-block;
        }
        
        .message-moderator .message-bubble {
            background-color: #f2f7ff;
            border: 1px solid #d1e0ff;
            border-bottom-left-radius: 0.25rem;
        }
        
        .message-participant .message-bubble {
            background-color: #f0f9ff;
            border: 1px solid #bae6fd;
            border-bottom-right-radius: 0.25rem;
            text-align: right;
        }
        
        .chat-input {
            display: flex;
            gap: 0.5rem;
        }
        
        .audio-visualizer {
            height: 60px;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 1rem;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        
        .btn-primary:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
        }
        
        .card {
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .speech-animation {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .speech-bar {
            width: 4px;
            height: 20px;
            background-color: var(--primary-color);
            border-radius: 2px;
            animation: speech-animation 0.8s infinite ease-in-out;
        }
        
        .speech-bar:nth-child(1) { animation-delay: 0s; }
        .speech-bar:nth-child(2) { animation-delay: 0.1s; }
        .speech-bar:nth-child(3) { animation-delay: 0.2s; }
        .speech-bar:nth-child(4) { animation-delay: 0.3s; }
        
        @keyframes speech-animation {
            0% { height: 5px; }
            50% { height: 20px; }
            100% { height: 5px; }
        }
    </style>
</head>
<body>
    <div class="session-container">
        <div class="container-fluid vh-100 d-flex flex-column">
            <!-- Header with session info -->
            <div class="bg-light py-2 px-3 border-bottom d-flex justify-content-between align-items-center">
                <div>
                    <h1 class="h5 mb-0">Research Session</h1>
                    <p class="text-muted small mb-0">
                        {{ guide.title if guide and guide.title else "Research Session" }}
                        <span class="badge bg-primary ms-2">{{ character_name|title if character_name else guide.character_select|title if guide and guide.character_select else "AI Interviewer" }}</span>
                    </p>
                </div>
                <div class="d-flex align-items-center">
                    <span class="me-3" id="session-timer">00:00</span>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="audioSwitch" checked>
                        <label class="form-check-label" for="audioSwitch">Audio</label>
                    </div>
                </div>
            </div>
            
            <div class="row mb-4">
                <div class="col-md-8">
                    <h1 class="h3">Research Session: {{ guide.title if guide else "Research Study" }}</h1>
                    <p class="text-muted">Thank you for participating in this research session. Please speak naturally when responding to questions.</p>
                </div>
                <div class="col-md-4 text-end">
                    <button type="button" class="btn btn-outline-danger" data-bs-toggle="modal" data-bs-target="#exitModal">
                        <i class="bi bi-door-open me-2"></i>Exit Session
                    </button>
                </div>
            </div>
            
            <!-- Status Bar -->
            <div class="status-bar mb-3">
                <div>
                    <span class="badge bg-success">Connected</span>
                    <span class="ms-2" id="session-timer">00:00</span>
                </div>
                <div>
                    <span class="d-flex align-items-center">
                        <i class="bi bi-mic-fill text-success me-2"></i>
                        <span id="mic-status">Microphone active</span>
                    </span>
                </div>
                <div>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#speechControls">
                        <i class="bi bi-sliders me-1"></i> Speech Controls
                    </button>
                </div>
            </div>
            
            <!-- Speech Recognition Controls -->
            <div class="collapse mb-3" id="speechControls">
                <div class="card card-body">
                    <h6 class="mb-3">Speech Recognition Settings</h6>
                    <div class="row g-3">
                        <div class="col-md-6">
                            <label for="silenceThreshold" class="form-label small">Silence Detection (seconds)</label>
                            <div class="d-flex align-items-center">
                                <input type="range" class="form-range me-2" id="silenceThreshold" min="0.5" max="5" step="0.5" value="2">
                                <span id="silenceThresholdValue" class="small">2s</span>
                            </div>
                            <div class="form-text small">Time of silence before sending message</div>
                        </div>
                        <div class="col-md-6">
                            <label for="noiseThreshold" class="form-label small">Noise Threshold</label>
                            <div class="d-flex align-items-center">
                                <input type="range" class="form-range me-2" id="noiseThreshold" min="0" max="100" value="15">
                                <span id="noiseThresholdValue" class="small">15%</span>
                            </div>
                            <div class="form-text small">Minimum volume to detect speech</div>
                        </div>
                        <div class="col-md-6">
                            <div class="form-check form-switch mt-2">
                                <input class="form-check-input" type="checkbox" id="audioVisualizerEnabled" checked>
                                <label class="form-check-label small" for="audioVisualizerEnabled">Show Audio Visualization</label>
                            </div>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="noiseFilterEnabled" checked>
                                <label class="form-check-label small" for="noiseFilterEnabled">Noise Filtering</label>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between">
                                <div id="audioLevel" class="mt-2 small">Audio Level: <span id="currentLevel">0</span>%</div>
                                <div id="silenceTimer" class="mt-2 small d-none">Silence: <span id="currentSilence">0</span>s</div>
                            </div>
                            <div class="progress mt-1" style="height: 10px;">
                                <div id="audioLevelBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Container -->
            <div class="chat-container">
                <div class="chat-messages" id="chat-messages">
                    <!-- Messages will be added here -->
                    <div class="message message-moderator">
                        <div class="message-bubble">
                            <p class="mb-0">Hello and welcome to this research session. I'll be asking you some questions about your experiences. Feel free to respond naturally.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Audio Visualizer -->
                <div class="audio-visualizer">
                    <div id="visualizer-inactive">
                        <i class="bi bi-mic-fill text-muted me-2"></i>
                        <span class="text-muted">Listening...</span>
                    </div>
                    <div id="visualizer-active" class="d-none">
                        <div class="speech-animation">
                            <div class="speech-bar"></div>
                            <div class="speech-bar"></div>
                            <div class="speech-bar"></div>
                            <div class="speech-bar"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Input Area (Text Fallback) -->
                <div class="chat-input">
                    <input type="text" class="form-control" id="text-input" placeholder="Type your response if microphone is not working...">
                    <button class="btn btn-primary" id="send-button">
                        <i class="bi bi-send"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Exit Confirmation Modal -->
    <div class="modal fade" id="exitModal" tabindex="-1" aria-labelledby="exitModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exitModalLabel">Exit Session</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to exit this research session? Your progress will be saved, but you won't be able to continue answering questions.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Continue Session</button>
                    <button type="button" class="btn btn-danger" id="confirm-exit-button">Exit Session</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Finished Session Modal -->
    <div class="modal fade" id="finishedModal" tabindex="-1" aria-labelledby="finishedModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="finishedModalLabel">Session Complete</h5>
                </div>
                <div class="modal-body">
                    <div class="text-center mb-4">
                        <i class="bi bi-check-circle text-success fs-1"></i>
                    </div>
                    <h4 class="text-center mb-3">Thank You!</h4>
                    <p>Thank you for participating in this research session. Your feedback is greatly appreciated and will help improve our products and services.</p>
                    <p>You may now close this window or browser tab.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" id="close-window-btn">Close Window</button>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let sessionId = '{{ session_id }}';
        let isRecording = false;
        let isSpeaking = false;
        let isProcessingMessage = false;
        
        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing interview page");
            
            // Extract session ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            sessionId = window.location.pathname.split('/').pop();
            isRemoteInterview = urlParams.get('remote') === 'true';
            
            // Prevent browser back navigation in remote interview
            if (isRemoteInterview) {
                // More reliable than history manipulation
                window.addEventListener('beforeunload', function(e) {
                    e.preventDefault();
                    e.returnValue = 'Are you sure you want to leave the interview?';
                    return 'Are you sure you want to leave the interview?';
                });
            }
            
            // Initialize UI elements
            initializePage();
            
            // Setup speech recognition
            setupSpeechRecognition();
            
            // Load initial messages
            loadInitialMessages();
            
            // Setup WebSocket connection for monitoring
            setupWebSocket();
            
            console.log("Page initialization complete");
        });
        
        // Function to initialize the page UI and event handlers
        function initializePage() {
            // Initialize UI elements
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) {
                console.log("Creating missing chat container");
                const container = document.createElement('div');
                container.id = 'chat-container';
                container.className = 'chat-container';
                
                const messagesDiv = document.createElement('div');
                messagesDiv.id = 'chat-messages';
                messagesDiv.className = 'chat-messages';
                
                container.appendChild(messagesDiv);
                document.querySelector('.session-container').appendChild(container);
            }
            console.log("Chat container initialized");
            
            // Initialize message controls if they don't exist
            const messageControls = document.getElementById('message-controls');
            if (!messageControls) {
                console.log("Creating missing message controls");
                const controls = document.createElement('div');
                controls.id = 'message-controls';
                controls.className = 'message-controls';
                
                // Add to the DOM
                document.querySelector('.session-container').appendChild(controls);
            }
            console.log("Message controls initialized");
            
            // Initialize event handlers
            document.getElementById('confirm-exit-button')?.addEventListener('click', endSession);
            
            // Initialize audio switch for TTS control
            const audioSwitch = document.getElementById('audioSwitch');
            if (audioSwitch) {
                audioSwitch.addEventListener('change', function() {
                    console.log("Audio " + (this.checked ? "enabled" : "disabled"));
                });
            }
        }
        
        // Function to end the session
        function endSession() {
            console.log("Ending interview session");
            
            // Safely stop any running speech recognition
            if (window.recognition) {
                safelyStopRecognition();
            }
            
            // Stop any TTS that might be playing
            if (window.currentTTSAudio) {
                window.currentTTSAudio.pause();
                window.currentTTSAudio.src = '';
                window.currentTTSAudio = null;
            }
            
            // Cancel any pending TTS requests
            if (window.currentTTSRequest) {
                window.currentTTSRequest.abort();
                window.currentTTSRequest = null;
            }
            
            // Show loading state in the button if it exists
            const exitButton = document.getElementById('confirm-exit-button');
            if (exitButton) {
                exitButton.disabled = true;
                exitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Exiting...';
            }
            
            // Add a system message indicating the interview is ending
            updateConversation('system', 'Interview session ending...');
            
            // Emit message to monitoring if socket is connected
            if (window.socket && window.socket.connected) {
                emitMessageViaSocket('Interview session ended by voice command', 'system');
            }
            
            // Send end session request to server
            fetch(`/api/session/${sessionId}/complete`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ completed: true })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Session completed successfully:", data);
                
                // Show success message
                updateConversation('system', 'Interview successfully completed. You may now close this window.');
                
                // Redirect to session summary page after a delay
                setTimeout(() => {
                    window.location.href = `/session/${sessionId}`;
                }, 2000);
            })
            .catch(error => {
                console.error("Error completing session:", error);
                
                // Show error message
                updateConversation('system', 'Error completing the interview. Please try again or close this window.');
                
                // Re-enable exit button if it exists
                if (exitButton) {
                    exitButton.disabled = false;
                    exitButton.innerHTML = 'Exit Interview';
                }
            });
        }
        
        // Send a user message to the server
        function sendMessage(text) {
            if (!text || !text.trim()) {
                console.warn("Empty message, not sending");
                return Promise.resolve();
            }
            
            // Check for voice commands first
            if (checkForVoiceCommands(text)) {
                console.log("Voice command detected, not sending as regular message");
                return Promise.resolve();
            }
            
            // Add message to UI
            updateConversation('user', text);
            
            console.log("Sending message to server:", text);
            
            // Also emit via WebSocket for monitoring
            if (window.socket && window.socket.connected) {
                emitMessageViaSocket(text, 'user');
            }
            
            // Send to server
            return fetch(`/api/session/${sessionId}/add_message`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    content: text,
                    role: 'user'
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Message sent successfully:", data);
                
                // Start polling for response
                pollForMessages();
                
                return data;
            })
            .catch(error => {
                console.error("Error sending message:", error);
                return Promise.reject(error);
            });
        }
        
        // Handle configuration of the speech recognition object
        function configureRecognition() {
            if (!window.recognition) {
                console.error("No recognition object to configure");
                return;
            }
            
            // Set up event handlers
            window.recognition.onstart = function() {
                console.log("Recognition started");
                window.recognition.recognitionState = 'running';
            };
            
            window.recognition.onresult = function(event) {
                // Skip if speaking
                if (isSpeaking) {
                    console.log("Ignoring speech recognition result while TTS is active");
                    return;
                }
                
                // Skip if processing message
                if (isProcessingMessage) {
                    console.log("Already processing message, skipping new results");
                    return;
                }
                
                // Process results
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                        console.log("Final transcript part:", finalTranscript);
                    } else {
                        interimTranscript += transcript;
                        console.log("Interim transcript:", interimTranscript);
                    }
                }
                
                // Update UI with interim results if needed
                if (interimTranscript && !finalTranscript) {
                    // Optional: show interim results in UI
                    const messageInput = document.getElementById('message-input');
                    if (messageInput) {
                        messageInput.value = interimTranscript;
                    }
                }
                
                // Process final transcript
                if (finalTranscript) {
                    // Check for voice commands
                    if (checkForVoiceCommands(finalTranscript)) {
                        return;
                    }
                    
                    // Set processing flag
                    isProcessingMessage = true;
                    
                    // Send message to server
                    sendMessage(finalTranscript)
                        .finally(() => {
                            // Reset processing flag
                            setTimeout(() => {
                                isProcessingMessage = false;
                            }, 1000);
                        });
                }
            };
            
            window.recognition.onerror = function(event) {
                console.error("Speech recognition error:", event.error);
                
                // Only try to auto-recover from certain errors
                if (event.error === 'no-speech' || event.error === 'audio-capture') {
                    // These are common and recoverable
                    setTimeout(() => {
                        if (window.recognition && window.recognition.recognitionState === 'running') {
                            try {
                                window.recognition.stop();
                                window.recognition.recognitionState = 'stopped';
                                
                                setTimeout(() => {
                                    startSpeechRecognition();
                                }, 300);
                            } catch (e) {
                                console.error("Error restarting recognition after error:", e);
                            }
                        }
                    }, 1000);
                }
            };
            
            window.recognition.onend = function() {
                console.log("Speech recognition ended");
                
                // Don't auto-restart if we're speaking
                if (isSpeaking) {
                    console.log("Not restarting recognition because TTS is active");
                    return;
                }
                
                // Don't auto-restart if we're in a stopping state
                if (window.recognition && window.recognition.recognitionState !== 'running') {
                    console.log("Recognition ended as expected, not auto-restarting");
                    return;
                }
                
                // Automatically restart recognition if it ends unexpectedly and we're not speaking
                console.log("Recognition ended unexpectedly, restarting");
                setTimeout(() => {
                    startSpeechRecognition();
                }, 300);
            };
        }
        
        // Function to safely stop speech recognition
        function safelyStopRecognition() {
            console.log("Safely stopping recognition");
            
            // If recognition exists, stop it
            if (window.recognition) {
                try {
                    // Mark recognition as intentionally stopping
                    window.recognition.recognitionState = 'stopping';
                    
                    // Stop the recognition instance
                    window.recognition.stop();
                    
                    // Clear reference to the recognition object
                    window.recognition = null;
                } catch (e) {
                    console.error("Error while stopping recognition:", e);
                }
            }
            
            // Update the UI
            const visualizerActive = document.getElementById('visualizer-active');
            const visualizerInactive = document.getElementById('visualizer-inactive');
            
            if (visualizerActive && visualizerInactive) {
                visualizerActive.classList.add('d-none');
                visualizerInactive.classList.remove('d-none');
            }
            
            // Update mic status if it exists
            const micStatus = document.getElementById('mic-status');
            if (micStatus) {
                micStatus.textContent = 'Microphone inactive';
            }
        }
        
        // Function to start speech recognition
        function startSpeechRecognition() {
            // Only start if not already running
            if (window.recognition && window.recognition.recognitionState === 'running') {
                console.log("Recognition already running, not starting again");
                return;
            }
            
            // If speaking, don't start recognition yet
            if (isSpeaking) {
                console.log("TTS is active, delaying speech recognition start");
                return;
            }
            
            try {
                // Create a new recognition instance
                if (!window.recognition) {
                    console.log("Creating new recognition instance");
                    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    window.recognition = new SpeechRecognition();
                    window.recognition.continuous = true;
                    window.recognition.interimResults = true;
                    
                    // Set default state
                    window.recognition.recognitionState = 'initializing';
                    
                    // Configure the recognition instance
                    configureRecognition();
                }
                
                // Start recognition
                window.recognition.start();
                
                // Update visuals
                const visualizerActive = document.getElementById('visualizer-active');
                const visualizerInactive = document.getElementById('visualizer-inactive');
                
                if (visualizerActive && visualizerInactive) {
                    visualizerInactive.classList.remove('d-none');
                    visualizerActive.classList.add('d-none');
                }
                
                // Update mic status if it exists
                const micStatus = document.getElementById('mic-status');
                if (micStatus) {
                    micStatus.textContent = 'Listening...';
                }
                
                console.log("Speech recognition started");
            } catch (e) {
                console.error("Error starting speech recognition:", e);
                
                // Clear recognition object if it failed to start
                window.recognition = null;
            }
        }
        
        // Function to setup speech recognition
        function setupSpeechRecognition() {
            console.log("Setting up speech recognition");
            
            if (!('webkitSpeechRecognition' in window)) {
                console.error("Speech recognition not supported in this browser");
                return;
            }
            
            // First, safely stop any previous recognition
            safelyStopRecognition();
            
            // Start new recognition instance (this will create and configure it)
            startSpeechRecognition();
        }
        
        // Function to check for voice commands in transcript
        function checkForVoiceCommands(transcript) {
            if (!transcript) return false;
            
            // Convert to lowercase for easier matching
            const text = transcript.toLowerCase().trim();
            
            console.log("Checking for voice commands in:", text);
            
            // Define command patterns
            const endInterviewPatterns = [
                'end interview',
                'end the interview',
                'finish interview',
                'stop interview',
                'end session',
                'exit interview',
                'terminate interview',
                'finish session',
                'exit session',
                'stop session',
                'conclude interview',
                'complete interview',
                'end it',
                'finish it'
            ];
            
            // Check for end interview command - use more flexible matching
            for (const pattern of endInterviewPatterns) {
                if (text.includes(pattern)) {
                    console.log(`Detected "${pattern}" command in: "${text}"`);
                    endSession();
                    return true;
                }
            }
            
            return false;
        }
        
        // Load initial chat messages
        function loadInitialMessages() {
            if (!sessionId) {
                console.error("No session ID available");
                return Promise.reject("No session ID available");
            }
            
            console.log("Loading initial messages");
            
            return fetch(`/api/session/${sessionId}/messages`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.messages && data.messages.length > 0) {
                        console.log(`Loaded ${data.messages.length} messages`);
                        
                        // Display all messages
                        data.messages.forEach(message => {
                            updateConversation(message.role, message.content, message.id);
                        });
                        
                        // Find the last assistant message for TTS
                        const lastAssistantMessage = [...data.messages].reverse().find(m => m.role === 'assistant');
                        if (lastAssistantMessage) {
                            // Play TTS for the latest assistant message
                            console.log("Initial messages loaded, TTS should start automatically");
                            setTimeout(() => {
                                playTTS(lastAssistantMessage.content)
                                    .catch(error => {
                                        console.error("Error playing initial TTS:", error);
                                        // Even if TTS fails, make sure we start speech recognition
                                        if (!isSpeaking) {
                                            startSpeechRecognition();
                                        }
                                    });
                            }, 1000); // Short delay to ensure DOM is ready
                        } else {
                            // Start speech recognition if no assistant message (unusual)
                            if (!isSpeaking) {
                                startSpeechRecognition();
                            }
                        }
                    } else {
                        console.log("No initial messages found");
                        // Start speech recognition since there's no TTS to play
                        startSpeechRecognition();
                    }
                    
                    return data.messages || [];
                })
                .catch(error => {
                    console.error("Error loading messages:", error);
                    // Start speech recognition even if message loading failed
                    startSpeechRecognition();
                    return [];
                });
        }
        
        // Update conversation UI with a new message
        function updateConversation(role, message, messageId) {
            console.log(`Adding ${role} message:`, message);
            const messagesContainer = document.getElementById('chat-messages');
            
            // Create message element
            const messageElement = document.createElement('div');
            messageElement.className = `message message-${role === 'user' ? 'participant' : 'moderator'}`;
            
            // Add message ID to the element if provided
            if (messageId) {
                messageElement.setAttribute('data-message-id', messageId);
            }
            
            // Create message bubble
            const messageBubble = document.createElement('div');
            messageBubble.className = 'message-bubble';
            messageBubble.textContent = message;
            
            // Add bubble to message element
            messageElement.appendChild(messageBubble);
            
            // Add message to container
            messagesContainer.appendChild(messageElement);
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Play text-to-speech for assistant messages
        function playTTS(text) {
            if (!text || text.trim() === '') {
                console.log("Empty text, skipping TTS");
                return Promise.resolve();
            }
            
            console.log("Starting TTS for text:", text.substring(0, 30) + "...");
            
            // Cancel any pending TTS requests to prevent multiple voices
            if (window.currentTTSRequest) {
                console.log("Cancelling previous TTS request");
                window.currentTTSRequest.abort();
                window.currentTTSRequest = null;
            }
            
            // Clear any pending TTS audio elements
            if (window.currentTTSAudio) {
                console.log("Stopping previous TTS audio");
                window.currentTTSAudio.pause();
                window.currentTTSAudio.src = '';
                window.currentTTSAudio = null;
            }
            
            // Stop any active speech recognition while speaking
            if (window.recognition) {
                console.log("Completely stopped speech recognition for TTS");
                safelyStopRecognition();
            }
            
            // Mark as speaking
            window.isSpeaking = true;
            
            // Update UI to show speaking state
            const visualizerActive = document.getElementById('visualizer-active');
            const visualizerInactive = document.getElementById('visualizer-inactive');
            
            if (visualizerActive && visualizerInactive) {
                visualizerActive.classList.remove('d-none');
                visualizerInactive.classList.add('d-none');
            }
            
            // Update mic status if it exists
            const micStatus = document.getElementById('mic-status');
            if (micStatus) {
                micStatus.textContent = 'AI is speaking...';
            }
            
            // Create AbortController for cancellable fetch
            const controller = new AbortController();
            window.currentTTSRequest = controller;
            
            // Create a promise to track TTS completion
            return new Promise((resolve, reject) => {
                // Call TTS API
                fetch('/api/text_to_speech_elevenlabs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ text: text }),
                    signal: controller.signal
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    // Create an audio element and store it globally
                    const audio = new Audio();
                    window.currentTTSAudio = audio;
                    
                    // Create blob URL
                    const blobUrl = URL.createObjectURL(blob);
                    audio.src = blobUrl;
                    
                    // Set up event handlers
                    audio.onended = function() {
                        console.log("TTS audio playback finished naturally");
                        // Revoke the blob URL to free memory
                        URL.revokeObjectURL(blobUrl);
                        window.currentTTSAudio = null;
                        handleTtsFinished();
                        resolve();
                    };
                    
                    audio.onerror = function(e) {
                        console.error("TTS audio playback error:", e);
                        URL.revokeObjectURL(blobUrl);
                        window.currentTTSAudio = null;
                        handleTtsFinished();
                        reject(e);
                    };
                    
                    // Play the audio
                    return audio.play()
                        .then(() => {
                            console.log("TTS audio playing");
                        })
                        .catch(error => {
                            console.error("Error playing TTS audio:", error);
                            URL.revokeObjectURL(blobUrl);
                            window.currentTTSAudio = null;
                            handleTtsFinished();
                            reject(error);
                        });
                })
                .catch(error => {
                    // Ignore abort errors
                    if (error.name === 'AbortError') {
                        console.log("TTS request was cancelled");
                        resolve();
                        return;
                    }
                    
                    console.error("Error with TTS:", error);
                    handleTtsFinished();
                    reject(error);
                });
            });
        }
        
        // Handle TTS playback finished
        function handleTtsFinished() {
            console.log("TTS playback finished");
            
            // Reset speaking flag
            window.isSpeaking = false;
            
            // Update UI
            const visualizerActive = document.getElementById('visualizer-active');
            const visualizerInactive = document.getElementById('visualizer-inactive');
            
            if (visualizerActive && visualizerInactive) {
                visualizerActive.classList.add('d-none');
                visualizerInactive.classList.remove('d-none');
            }
            
            // Update mic status if it exists
            const micStatus = document.getElementById('mic-status');
            if (micStatus) {
                micStatus.textContent = 'Listening...';
            }
            
            // Restart speech recognition with a slight delay to ensure everything is reset
            setTimeout(() => {
                setupSpeechRecognition();
            }, 300);
        }
        
        // Poll for new messages from the assistant
        function pollForMessages() {
            // Get the current message count
            const messagesContainer = document.getElementById('chat-messages');
            const initialCount = messagesContainer.children.length;
            
            // Track the latest message ID we've seen
            let latestMessageId = null;
            
            // Get all message elements to find the latest ID
            const messageElements = messagesContainer.querySelectorAll('.message');
            if (messageElements.length > 0) {
                for (const element of messageElements) {
                    const messageId = element.getAttribute('data-message-id');
                    if (messageId) {
                        latestMessageId = messageId;
                    }
                }
            }
            
            console.log(`Starting polling with latest message ID: ${latestMessageId}`);
            
            // Keep track of already seen message IDs to prevent duplicates
            const seenMessageIds = new Set();
            messageElements.forEach(el => {
                const id = el.getAttribute('data-message-id');
                if (id) seenMessageIds.add(id);
            });
            
            // Define polling function
            const checkForNewMessages = () => {
                return fetch(`/api/session/${sessionId}/messages`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.messages && data.messages.length > 0) {
                            // Find new messages we haven't seen yet
                            const newMessages = data.messages.filter(message => 
                                message.id && !seenMessageIds.has(message.id)
                            );
                            
                            if (newMessages.length > 0) {
                                console.log(`Found ${newMessages.length} new messages`);
                                
                                // Process each new message
                                let hasNewAssistantMessage = false;
                                let lastAssistantMessage = null;
                                
                                newMessages.forEach(message => {
                                    // Add to seen messages to prevent duplicates
                                    if (message.id) {
                                        seenMessageIds.add(message.id);
                                    }
                                    
                                    // Only add assistant messages (user messages were added locally)
                                    if (message.role === 'assistant') {
                                        hasNewAssistantMessage = true;
                                        lastAssistantMessage = message;
                                        
                                        // Add to UI
                                        updateConversation('assistant', message.content, message.id);
                                    }
                                });
                                
                                // Play TTS for the last assistant message
                                if (hasNewAssistantMessage && lastAssistantMessage) {
                                    playTTS(lastAssistantMessage.content);
                                }
                                
                                return hasNewAssistantMessage; // Stop polling if we got an assistant message
                            }
                        }
                        
                        return false; // Continue polling
                    })
                    .catch(error => {
                        console.error("Error polling for messages:", error);
                        return true; // Stop polling on error
                    });
            };
            
            // Poll more frequently at first, then less often
            let attempts = 0;
            const maxAttempts = 20; // Increased from 15
            const pollInterval = setInterval(() => {
                attempts++;
                
                checkForNewMessages()
                    .then(shouldStopPolling => {
                        // Stop polling if we found messages or reached max attempts
                        if (shouldStopPolling || attempts >= maxAttempts) {
                            clearInterval(pollInterval);
                            console.log("Polling complete");
                        }
                    });
                
                // Polling frequency: 1s for first 5 attempts, 2s for next 5, then 3s
                if (attempts < 5) {
                    // Already set at start
                } else if (attempts === 5) {
                    clearInterval(pollInterval);
                    setInterval(checkForNewMessages, 2000);
                } else if (attempts === 10) {
                    clearInterval(pollInterval);
                    setInterval(checkForNewMessages, 3000);
                }
            }, 1000); // Start with 1s interval
        }
        
        // Setup WebSocket connection for monitoring
        function setupWebSocket() {
            console.log("Setting up WebSocket connection for monitoring");
            
            try {
                // Skip if monitoring WebSocket isn't needed
                if (!window.location.href.includes('remote=true')) {
                    console.log("Not a remote session, skipping WebSocket setup");
                    return;
                }
                
                // First try to locate if socket.io is already loaded
                if (typeof io === 'undefined') {
                    console.log("Socket.IO not available, loading it now");
                    
                    // Try to load Socket.IO from the server first
                    const script = document.createElement('script');
                    const protocol = window.location.protocol;
                    const host = window.location.host;
                    script.src = `${protocol}//${host}/socket.io/socket.io.js`;
                    script.crossOrigin = 'anonymous';
                    
                    script.onerror = function() {
                        console.log("Failed to load Socket.IO from server, trying CDN");
                        // If server version fails, try CDN
                        const cdnScript = document.createElement('script');
                        cdnScript.src = 'https://cdn.socket.io/socket.io-3.0.5.js';
                        cdnScript.crossOrigin = 'anonymous';
                        
                        cdnScript.onload = initializeSocketConnection;
                        cdnScript.onerror = function() {
                            console.error("Failed to load Socket.IO from CDN");
                        };
                        
                        document.head.appendChild(cdnScript);
                    };
                    
                    script.onload = initializeSocketConnection;
                    document.head.appendChild(script);
                } else {
                    console.log("Socket.IO already available");
                    initializeSocketConnection();
                }
            } catch (error) {
                console.error("Error setting up WebSocket:", error);
            }
        }
        
        // Initialize Socket.IO connection
        function initializeSocketConnection() {
            if (typeof io === 'undefined') {
                console.error("Socket.IO library not loaded");
                return;
            }
            
            try {
                // Only create one socket connection
                if (!window.socket) {
                    console.log("Creating socket connection");
                    
                    // Set connection options
                    const options = {
                        reconnection: true,
                        reconnectionAttempts: 5,
                        reconnectionDelay: 1000,
                        transports: ['websocket', 'polling'] // Prefer WebSocket
                    };
                    
                    // Connect using current host
                    window.socket = io(window.location.origin, options);
                    
                    // Set up socket event handlers
                    window.socket.on('connect', function() {
                        console.log('Socket connected successfully');
                        
                        // Join the monitoring room for this session
                        window.socket.emit('join', { session_id: sessionId });
                        
                        // Send a test message
                        emitMessageViaSocket('Socket connection established', 'system');
                    });
                    
                    window.socket.on('connect_error', function(error) {
                        console.error('Socket connection error:', error);
                    });
                    
                    window.socket.on('disconnect', function() {
                        console.log('Socket disconnected');
                    });
                    
                    window.socket.on('message', function(data) {
                        console.log('Received message via socket:', data);
                    });
                } else {
                    console.log("Socket connection already exists");
                    
                    // Make sure we're connected
                    if (!window.socket.connected) {
                        console.log("Reconnecting existing socket");
                        window.socket.connect();
                    }
                }
            } catch (error) {
                console.error("Error initializing socket connection:", error);
            }
        }
        
        // Emit message via WebSocket for monitoring
        function emitMessageViaSocket(message, role) {
            if (!window.socket) {
                console.log("Socket not initialized, can't emit message");
                return;
            }
            
            if (!window.socket.connected) {
                console.log("Socket not connected, attempting to reconnect");
                window.socket.connect();
                
                // Try again after connection attempt
                setTimeout(() => {
                    if (window.socket.connected) {
                        emitMessageViaSocket(message, role);
                    } else {
                        console.log("Socket reconnection failed, message not sent");
                    }
                }, 1000);
                return;
            }
            
            try {
                console.log(`Emitting ${role} message to monitoring via socket`);
                window.socket.emit('message', {
                    session_id: sessionId,
                    role: role,
                    content: message,
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                console.error("Error emitting message via socket:", error);
            }
        }
    </script>
</body>
</html> 