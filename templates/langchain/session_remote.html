<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Session</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --secondary-color: #0ea5e9;
            --text-color: #1f2937;
            --text-muted: #6b7280;
            --light-bg: #f9fafb;
            --card-bg: #ffffff;
            --border-color: #e5e7eb;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-bg);
            color: var(--text-color);
            min-height: 100vh;
        }
        
        .session-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        
        .chat-container {
            height: calc(100vh - 250px);
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .message {
            margin-bottom: 1rem;
            max-width: 80%;
        }
        
        .message-moderator {
            margin-right: auto;
        }
        
        .message-participant {
            margin-left: auto;
        }
        
        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            display: inline-block;
        }
        
        .message-moderator .message-bubble {
            background-color: #f2f7ff;
            border: 1px solid #d1e0ff;
            border-bottom-left-radius: 0.25rem;
        }
        
        .message-participant .message-bubble {
            background-color: #f0f9ff;
            border: 1px solid #bae6fd;
            border-bottom-right-radius: 0.25rem;
            text-align: right;
        }
        
        .chat-input {
            display: flex;
            gap: 0.5rem;
        }
        
        .audio-visualizer {
            height: 60px;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 1rem;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        
        .btn-primary:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
        }
        
        .card {
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .speech-animation {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .speech-bar {
            width: 4px;
            height: 20px;
            background-color: var(--primary-color);
            border-radius: 2px;
            animation: speech-animation 0.8s infinite ease-in-out;
        }
        
        .speech-bar:nth-child(1) { animation-delay: 0s; }
        .speech-bar:nth-child(2) { animation-delay: 0.1s; }
        .speech-bar:nth-child(3) { animation-delay: 0.2s; }
        .speech-bar:nth-child(4) { animation-delay: 0.3s; }
        
        @keyframes speech-animation {
            0% { height: 5px; }
            50% { height: 20px; }
            100% { height: 5px; }
        }
    </style>
</head>
<body>
    <div class="session-container">
        <div class="container-fluid vh-100 d-flex flex-column">
            <!-- Header with session info -->
            <div class="bg-light py-2 px-3 border-bottom d-flex justify-content-between align-items-center">
                <div>
                    <h1 class="h5 mb-0">Research Session</h1>
                    <p class="text-muted small mb-0">
                        {{ guide.title if guide and guide.title else "Research Session" }}
                        <span class="badge bg-primary ms-2">{{ character_name|title if character_name else guide.character_select|title if guide and guide.character_select else "AI Interviewer" }}</span>
                    </p>
                </div>
                <div class="d-flex align-items-center">
                    <span class="me-3" id="session-timer">00:00</span>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="audioSwitch" checked>
                        <label class="form-check-label" for="audioSwitch">Audio</label>
                    </div>
                </div>
            </div>
            
            <div class="row mb-4">
                <div class="col-md-8">
                    <h1 class="h3">Research Session: {{ guide.title if guide else "Research Study" }}</h1>
                    <p class="text-muted">Thank you for participating in this research session. Please speak naturally when responding to questions.</p>
                </div>
                <div class="col-md-4 text-end">
                    <button type="button" class="btn btn-outline-danger" data-bs-toggle="modal" data-bs-target="#exitModal">
                        <i class="bi bi-door-open me-2"></i>Exit Session
                    </button>
                </div>
            </div>
            
            <!-- Status Bar -->
            <div class="status-bar mb-3">
                <div>
                    <span class="badge bg-success">Connected</span>
                    <span class="ms-2" id="session-timer">00:00</span>
                </div>
                <div>
                    <span class="d-flex align-items-center">
                        <i class="bi bi-mic-fill text-success me-2"></i>
                        <span id="mic-status">Microphone active</span>
                    </span>
                </div>
                <div>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#speechControls">
                        <i class="bi bi-sliders me-1"></i> Speech Controls
                    </button>
                </div>
            </div>
            
            <!-- Speech Recognition Controls -->
            <div class="collapse mb-3" id="speechControls">
                <div class="card card-body">
                    <h6 class="mb-3">Speech Recognition Settings</h6>
                    <div class="row g-3">
                        <div class="col-md-6">
                            <label for="silenceThreshold" class="form-label small">Silence Detection (seconds)</label>
                            <div class="d-flex align-items-center">
                                <input type="range" class="form-range me-2" id="silenceThreshold" min="0.5" max="5" step="0.5" value="2">
                                <span id="silenceThresholdValue" class="small">2s</span>
                            </div>
                            <div class="form-text small">Time of silence before sending message</div>
                        </div>
                        <div class="col-md-6">
                            <label for="noiseThreshold" class="form-label small">Noise Threshold</label>
                            <div class="d-flex align-items-center">
                                <input type="range" class="form-range me-2" id="noiseThreshold" min="0" max="100" value="15">
                                <span id="noiseThresholdValue" class="small">15%</span>
                            </div>
                            <div class="form-text small">Minimum volume to detect speech</div>
                        </div>
                        <div class="col-md-6">
                            <div class="form-check form-switch mt-2">
                                <input class="form-check-input" type="checkbox" id="audioVisualizerEnabled" checked>
                                <label class="form-check-label small" for="audioVisualizerEnabled">Show Audio Visualization</label>
                            </div>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="noiseFilterEnabled" checked>
                                <label class="form-check-label small" for="noiseFilterEnabled">Noise Filtering</label>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between">
                                <div id="audioLevel" class="mt-2 small">Audio Level: <span id="currentLevel">0</span>%</div>
                                <div id="silenceTimer" class="mt-2 small d-none">Silence: <span id="currentSilence">0</span>s</div>
                            </div>
                            <div class="progress mt-1" style="height: 10px;">
                                <div id="audioLevelBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Container -->
            <div class="chat-container">
                <div class="chat-messages" id="chat-messages">
                    <!-- Messages will be added here -->
                    <div class="message message-moderator">
                        <div class="message-bubble">
                            <p class="mb-0">Hello and welcome to this research session. I'll be asking you some questions about your experiences. Feel free to respond naturally.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Audio Visualizer -->
                <div class="audio-visualizer">
                    <div id="visualizer-inactive">
                        <i class="bi bi-mic-fill text-muted me-2"></i>
                        <span class="text-muted">Listening...</span>
                    </div>
                    <div id="visualizer-active" class="d-none">
                        <div class="speech-animation">
                            <div class="speech-bar"></div>
                            <div class="speech-bar"></div>
                            <div class="speech-bar"></div>
                            <div class="speech-bar"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Input Area (Text Fallback) -->
                <div class="chat-input">
                    <input type="text" class="form-control" id="text-input" placeholder="Type your response if microphone is not working...">
                    <button class="btn btn-primary" id="send-button">
                        <i class="bi bi-send"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Exit Confirmation Modal -->
    <div class="modal fade" id="exitModal" tabindex="-1" aria-labelledby="exitModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exitModalLabel">Exit Session</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to exit this research session? Your progress will be saved, but you won't be able to continue answering questions.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Continue Session</button>
                    <button type="button" class="btn btn-danger" id="confirm-exit-button">Exit Session</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Finished Session Modal -->
    <div class="modal fade" id="finishedModal" tabindex="-1" aria-labelledby="finishedModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="finishedModalLabel">Session Complete</h5>
                </div>
                <div class="modal-body">
                    <div class="text-center mb-4">
                        <i class="bi bi-check-circle text-success fs-1"></i>
                    </div>
                    <h4 class="text-center mb-3">Thank You!</h4>
                    <p>Thank you for participating in this research session. Your feedback is greatly appreciated and will help improve our products and services.</p>
                    <p>You may now close this window or browser tab.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" id="close-window-btn">Close Window</button>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let sessionId = '{{ session_id }}';
        let isRecording = false;
        let isSpeaking = false;
        let isProcessingMessage = false;
        
        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing interview page");
            
            // Extract session ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            sessionId = window.location.pathname.split('/').pop();
            isRemoteInterview = urlParams.get('remote') === 'true';
            
            // Prevent browser back navigation in remote interview
            if (isRemoteInterview) {
                // More reliable than history manipulation
                window.addEventListener('beforeunload', function(e) {
                    e.preventDefault();
                    e.returnValue = 'Are you sure you want to leave the interview?';
                    return 'Are you sure you want to leave the interview?';
                });
            }
            
            // Initialize UI elements
            initializePage();
            
            // Setup speech recognition
            setupSpeechRecognition();
            
            // Load initial messages
            loadInitialMessages();
            
            // Setup WebSocket connection for monitoring
            setupWebSocket();
            
            console.log("Page initialization complete");
        });
        
        // Function to initialize the page UI and event handlers
        function initializePage() {
            // Initialize UI elements
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) {
                console.log("Creating missing chat container");
                const container = document.createElement('div');
                container.id = 'chat-container';
                container.className = 'chat-container';
                
                const messagesDiv = document.createElement('div');
                messagesDiv.id = 'chat-messages';
                messagesDiv.className = 'chat-messages';
                
                container.appendChild(messagesDiv);
                document.querySelector('.session-container').appendChild(container);
            }
            console.log("Chat container initialized");
            
            // Initialize message controls if they don't exist
            const messageControls = document.getElementById('message-controls');
            if (!messageControls) {
                console.log("Creating missing message controls");
                const controls = document.createElement('div');
                controls.id = 'message-controls';
                controls.className = 'message-controls';
                
                // Add to the DOM
                document.querySelector('.session-container').appendChild(controls);
            }
            console.log("Message controls initialized");
            
            // Initialize event handlers
            document.getElementById('confirm-exit-button')?.addEventListener('click', endSession);
            
            // Initialize audio switch for TTS control
            const audioSwitch = document.getElementById('audioSwitch');
            if (audioSwitch) {
                audioSwitch.addEventListener('change', function() {
                    console.log("Audio " + (this.checked ? "enabled" : "disabled"));
                });
            }
        }
        
        // Function to end the session
        function endSession() {
            console.log("Ending interview session");
            
            // Safely stop any running speech recognition
            if (window.recognition) {
                safelyStopRecognition();
            }
            
            // Stop any TTS that might be playing
            if (window.currentTTSAudio) {
                window.currentTTSAudio.pause();
                window.currentTTSAudio.src = '';
                window.currentTTSAudio = null;
            }
            
            // Cancel any pending TTS requests
            if (window.currentTTSRequest) {
                window.currentTTSRequest.abort();
                window.currentTTSRequest = null;
            }
            
            // Show loading state in the button if it exists
            const exitButton = document.getElementById('confirm-exit-button');
            if (exitButton) {
                exitButton.disabled = true;
                exitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Exiting...';
            }
            
            // Add a system message indicating the interview is ending
            updateConversation('system', 'Interview session ending...');
            
            // Emit message to monitoring if socket is connected
            if (window.socket && window.socket.connected) {
                emitMessageViaSocket('Interview session ended by voice command', 'system');
            }
            
            // Send end session request to server
            fetch(`/api/session/${sessionId}/complete`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ completed: true })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Session completed successfully:", data);
                
                // Show success message
                updateConversation('system', 'Interview successfully completed. You may now close this window.');
                
                // Redirect to session summary page after a delay
                setTimeout(() => {
                    window.location.href = `/session/${sessionId}`;
                }, 2000);
            })
            .catch(error => {
                console.error("Error completing session:", error);
                
                // Show error message
                updateConversation('system', 'Error completing the interview. Please try again or close this window.');
                
                // Re-enable exit button if it exists
                if (exitButton) {
                    exitButton.disabled = false;
                    exitButton.innerHTML = 'Exit Interview';
                }
            });
        }
        
        // Send a user message to the server
        function sendMessage(text) {
            if (!text || !text.trim()) {
                console.warn("Empty message, not sending");
                return Promise.resolve();
            }
            
            // Check for voice commands first
            if (checkForVoiceCommands(text)) {
                console.log("Voice command detected, not sending as regular message");
                return Promise.resolve();
            }
            
            // Add message to UI
            updateConversation('user', text);
            
            console.log("Sending message to server:", text);
            
            // Also emit via WebSocket for monitoring
            if (window.socket && window.socket.connected) {
                emitMessageViaSocket(text, 'user');
            }
            
            // Send to server
            return fetch(`/api/session/${sessionId}/add_message`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    content: text,
                    role: 'user'
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Message sent successfully:", data);
                
                // Start polling for response
                pollForMessages();
                
                return data;
            })
            .catch(error => {
                console.error("Error sending message:", error);
                return Promise.reject(error);
            });
        }
        
        // Handle configuration of the speech recognition object
        function configureRecognition() {
            if (!window.recognition) {
                console.error("No recognition object to configure");
                return;
            }
            
            // Set up event handlers
            window.recognition.onstart = function() {
                console.log("Recognition started");
                window.recognition.recognitionState = 'running';
            };
            
            window.recognition.onresult = function(event) {
                // Skip if speaking
                if (isSpeaking) {
                    console.log("Ignoring speech recognition result while TTS is active");
                    return;
                }
                
                // Skip if processing message
                if (isProcessingMessage) {
                    console.log("Already processing message, skipping new results");
                    return;
                }
                
                // Process results
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                        console.log("Final transcript part:", finalTranscript);
                    } else {
                        interimTranscript += transcript;
                        console.log("Interim transcript:", interimTranscript);
                    }
                }
                
                // Update UI with interim results if needed
                if (interimTranscript && !finalTranscript) {
                    // Optional: show interim results in UI
                    const messageInput = document.getElementById('message-input');
                    if (messageInput) {
                        messageInput.value = interimTranscript;
                    }
                }
                
                // Process final transcript
                if (finalTranscript) {
                    // Check for voice commands
                    if (checkForVoiceCommands(finalTranscript)) {
                        return;
                    }
                    
                    // Set processing flag
                    isProcessingMessage = true;
                    
                    // Send message to server
                    sendMessage(finalTranscript)
                        .finally(() => {
                            // Reset processing flag
                            setTimeout(() => {
                                isProcessingMessage = false;
                            }, 1000);
                        });
                }
            };
            
            window.recognition.onerror = function(event) {
                console.error("Speech recognition error:", event.error);
                
                // Only try to auto-recover from certain errors
                if (event.error === 'no-speech' || event.error === 'audio-capture') {
                    // These are common and recoverable
                    setTimeout(() => {
                        if (window.recognition && window.recognition.recognitionState === 'running') {
                            try {
                                window.recognition.stop();
                                window.recognition.recognitionState = 'stopped';
                                
                                setTimeout(() => {
                                    startSpeechRecognition();
                                }, 300);
                            } catch (e) {
                                console.error("Error restarting recognition after error:", e);
                            }
                        }
                    }, 1000);
                }
            };
            
            window.recognition.onend = function() {
                console.log("Speech recognition ended");
                
                // Don't auto-restart if we're speaking
                if (isSpeaking) {
                    console.log("Not restarting recognition because TTS is active");
                    return;
                }
                
                // Don't auto-restart if we're in a stopping state
                if (window.recognition && window.recognition.recognitionState !== 'running') {
                    console.log("Recognition ended as expected, not auto-restarting");
                    return;
                }
                
                // Automatically restart recognition if it ends unexpectedly and we're not speaking
                console.log("Recognition ended unexpectedly, restarting");
                setTimeout(() => {
                    startSpeechRecognition();
                }, 300);
            };
        }
        
        // Function to safely stop recognition without crashes
        function safelyStopRecognition() {
            console.log("Safely stopping recognition");
            
            try {
                if (window.recognition) {
                    // Remove all event handlers to prevent zombie callbacks
                    window.recognition.onresult = null;
                    window.recognition.onend = null;
                    window.recognition.onerror = null;
                    window.recognition.onstart = null;
                    
                    // Attempt to stop if running
                    if (window.recognition.isStarted) {
                        window.recognition.abort();
                    } else {
                        window.recognition.stop();
                    }
                    
                    window.recognition = null;
                }
            } catch (e) {
                console.error("Error stopping recognition:", e);
                // Force reset
                window.recognition = null;
            }
        }
        
        // Function to start speech recognition with proper state handling
        function startSpeechRecognition() {
            // Don't start if we're already speaking via TTS
            if (window.isSpeaking) {
                console.log("Recognition already running, not starting again");
                return;
            }
            
            try {
                // If recognition exists and appears to be running, don't restart
                if (window.recognition && window.recognition.isStarted) {
                    console.log("Recognition already running, not starting again");
                    return;
                }
                
                if (!window.recognition) {
                    console.log("No recognition instance, setting up first");
                    setupSpeechRecognition();
                    return;
                }
                
                // Set up event handlers before starting
                window.recognition.onresult = function(event) {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    
                    // Process results
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }
                    
                    // Update live transcript display if available
                    const liveTranscript = document.getElementById('live-transcript');
                    if (liveTranscript) {
                        liveTranscript.textContent = interimTranscript || finalTranscript || '';
                    }
                    
                    // Process final transcripts
                    if (finalTranscript) {
                        console.log("Final transcript:", finalTranscript);
                        
                        // Stop recognition before processing to prevent feedback loops
                        window.recognition.stop();
                        
                        // Reset the live transcript
                        if (liveTranscript) {
                            liveTranscript.textContent = '';
                        }
                        
                        // Send the message (if not a command)
                        sendMessage(finalTranscript);
                    }
                };
                
                // Start recognition
                console.log("Starting speech recognition");
                window.recognition.start();
                window.recognition.isStarted = true;
                
                // Update UI
                const micStatus = document.getElementById('mic-status');
                if (micStatus) {
                    micStatus.textContent = 'Listening...';
                    micStatus.classList.add('text-success');
                    micStatus.classList.remove('text-danger', 'text-warning');
                }
                
                console.log("Recognition started");
            } catch (error) {
                console.error("Error starting speech recognition:", error);
                
                // Set recognition as not started
                if (window.recognition) {
                    window.recognition.isStarted = false;
                }
                
                // Update UI to show error
                const micStatus = document.getElementById('mic-status');
                if (micStatus) {
                    micStatus.textContent = 'Microphone error';
                    micStatus.classList.add('text-danger');
                    micStatus.classList.remove('text-success');
                }
                
                // Try to recover after a delay
                setTimeout(setupSpeechRecognition, 3000);
            }
        }
        
        // Function to setup speech recognition
        function setupSpeechRecognition() {
            console.log("Setting up speech recognition");
            
            // Check if the browser supports speech recognition
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.error("Speech recognition not supported by this browser");
                
                // Show fallback text input
                const textInput = document.getElementById('text-input');
                if (textInput) {
                    textInput.style.display = 'block';
                }
                
                return;
            }
            
            // Don't recreate if TTS is currently playing
            if (isSpeaking) {
                console.log("TTS is playing, not setting up speech recognition yet");
                return;
            }
            
            // Safely stop any existing recognition first
            safelyStopRecognition();
            
            // Create a speech recognition instance
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            try {
                // Create new recognition instance
                console.log("Creating new recognition instance");
                window.recognition = new SpeechRecognition();
                
                // Configure recognition options
                window.recognition.continuous = true;
                window.recognition.interimResults = true;
                window.recognition.maxAlternatives = 1;
                window.recognition.lang = 'en-US';
                
                // Error handling with recovery
                window.recognition.onerror = function(event) {
                    console.log(`Speech recognition error: ${event.error}`);
                    
                    // Handle no-speech errors specifically
                    if (event.error === 'no-speech') {
                        if (!isSpeaking) {
                            // Just log, don't treat as fatal since this is common
                            console.log("No speech detected yet, continuing recognition");
                        }
                    } else if (event.error === 'network') {
                        console.error("Network error in speech recognition");
                        // Try to restart after a delay
                        setTimeout(setupSpeechRecognition, 3000);
                    } else if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        console.error("Microphone access denied");
                        // Show message to user
                        updateConversation('system', 'Microphone access was denied. Please enable your microphone and reload the page.');
                    } else {
                        console.error(`Speech recognition error: ${event.error}`);
                    }
                };
                
                // Handle end of recognition (should restart if not deliberate)
                window.recognition.onend = function() {
                    console.log("Speech recognition ended");
                    
                    // Don't restart if we're currently speaking
                    if (isSpeaking) {
                        console.log("TTS is active, not restarting recognition");
                        return;
                    }
                    
                    // Don't restart if we're exiting the page
                    if (window.isExiting) {
                        console.log("Page is exiting, not restarting recognition");
                        return;
                    }
                    
                    console.log("Recognition ended unexpectedly, restarting");
                    
                    // Restart with a short delay
                    setTimeout(function() {
                        setupSpeechRecognition();
                        startSpeechRecognition();
                    }, 300);
                };
                
                // Optional: handle permission state changes in Chrome
                navigator.permissions?.query({name: 'microphone'})
                    .then(permissionStatus => {
                        permissionStatus.onchange = function() {
                            if (this.state === 'granted') {
                                setupSpeechRecognition();
                                startSpeechRecognition();
                            } else {
                                console.log(`Microphone permission: ${this.state}`);
                                safelyStopRecognition();
                            }
                        };
                    })
                    .catch(error => {
                        console.log("Permission query not supported:", error);
                    });
                
                console.log("Speech recognition started");
                startSpeechRecognition();
            } catch (error) {
                console.error("Error setting up speech recognition:", error);
                // Show text input as fallback
                const textInput = document.getElementById('text-input');
                if (textInput) {
                    textInput.style.display = 'block';
                }
            }
        }
        
        // Check for voice commands
        function checkForVoiceCommands(text) {
            if (!text) return false;
            
            const lowerText = text.toLowerCase().trim();
            
            // Enhanced end command detection with more patterns
            const endCommands = [
                'end session', 'end interview', 'end the session', 'end the interview',
                'finish session', 'finish interview', 'finish the session', 'finish the interview',
                'stop session', 'stop interview', 'stop the session', 'stop the interview',
                'exit session', 'exit interview', 'exit the session', 'exit the interview',
                'conclude session', 'conclude interview', 'conclude the session', 'conclude the interview'
            ];
            
            // Check for end commands with lenient matching
            for (const command of endCommands) {
                if (lowerText.includes(command)) {
                    console.log(`Voice command detected: "${command}" in "${lowerText}"`);
                    endSession();
                    return true;
                }
            }
            
            return false;
        }
        
        // Load initial chat messages with improved error handling
        function loadInitialMessages() {
            if (!sessionId) {
                console.error("No session ID available");
                return Promise.reject("No session ID available");
            }
            
            console.log("Loading initial messages");
            
            return fetch(`/api/session/${sessionId}/messages`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data.success) {
                        console.error("Error in API response:", data.error || "Unknown error");
                        throw new Error(data.error || "Unknown error in API response");
                    }
                    
                    if (data.messages && data.messages.length > 0) {
                        console.log(`Loaded ${data.messages.length} messages`);
                        
                        // Display all messages
                        data.messages.forEach(message => {
                            updateConversation(message.role, message.content, message.id);
                        });
                        
                        // Find the last assistant message for TTS
                        const lastAssistantMessage = [...data.messages].reverse().find(m => m.role === 'assistant');
                        if (lastAssistantMessage) {
                            // Initialize audio context early
                            initializeAudioContext();
                            
                            // Play TTS after a short delay to ensure the DOM is updated
                            setTimeout(() => {
                                console.log("Playing TTS for initial assistant message");
                                playTTS(lastAssistantMessage.content)
                                    .catch(error => {
                                        console.error("Failed to play initial TTS:", error);
                                        // Start speech recognition if TTS fails
                                        startSpeechRecognition();
                                    });
                            }, 500);
                        } else {
                            // No assistant message to play, start recognition
                            startSpeechRecognition();
                        }
                    } else {
                        console.log("No initial messages found");
                        startSpeechRecognition(); 
                    }
                    
                    return data.messages || [];
                })
                .catch(error => {
                    console.error("Error loading messages:", error);
                    // Start speech recognition even if there was an error
                    startSpeechRecognition();
                    return [];
                });
        }
        
        // Initialize audio context for TTS
        function initializeAudioContext() {
            if (window.audioContextInitialized) return;
            
            try {
                // Create and initialize audio context
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    window.audioContext = new AudioContext();
                    
                    // Create a silent oscillator to initialize audio
                    const oscillator = window.audioContext.createOscillator();
                    oscillator.connect(window.audioContext.destination);
                    oscillator.start();
                    oscillator.stop(window.audioContext.currentTime + 0.001);
                    
                    window.audioContextInitialized = true;
                    console.log("Audio context initialized successfully");
                    
                    // Add a click listener to resume audio context if it gets suspended
                    document.addEventListener('click', function resumeAudioContext() {
                        if (window.audioContext && window.audioContext.state === 'suspended') {
                            window.audioContext.resume().then(() => {
                                console.log("Audio context resumed by user interaction");
                            });
                        }
                    });
                }
            } catch (error) {
                console.error("Error initializing audio context:", error);
            }
        }
        
        // Play text-to-speech for assistant messages
        function playTTS(text) {
            if (!text || text.trim() === '') {
                console.log("Empty text, skipping TTS");
                return Promise.resolve();
            }
            
            console.log("Starting TTS for text:", text.substring(0, 30) + "...");
            
            // Cancel any pending TTS requests to prevent multiple voices
            if (window.currentTTSRequest) {
                console.log("Cancelling previous TTS request");
                window.currentTTSRequest.abort();
                window.currentTTSRequest = null;
            }
            
            // Clear any pending TTS audio elements
            if (window.currentTTSAudio) {
                console.log("Stopping previous TTS audio");
                window.currentTTSAudio.pause();
                window.currentTTSAudio.src = '';
                window.currentTTSAudio = null;
            }
            
            // Stop any active speech recognition while speaking
            if (window.recognition) {
                console.log("Completely stopped speech recognition for TTS");
                safelyStopRecognition();
            }
            
            // Mark as speaking
            window.isSpeaking = true;
            
            // Update UI to show speaking state
            const visualizerActive = document.getElementById('visualizer-active');
            const visualizerInactive = document.getElementById('visualizer-inactive');
            
            if (visualizerActive && visualizerInactive) {
                visualizerActive.classList.remove('d-none');
                visualizerInactive.classList.add('d-none');
            }
            
            // Update mic status if it exists
            const micStatus = document.getElementById('mic-status');
            if (micStatus) {
                micStatus.textContent = 'AI is speaking...';
            }
            
            // Create AbortController for cancellable fetch
            const controller = new AbortController();
            window.currentTTSRequest = controller;
            
            // Create a promise to track TTS completion
            return new Promise((resolve, reject) => {
                // Call TTS API
                fetch('/api/text_to_speech_elevenlabs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ text: text }),
                    signal: controller.signal
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    // Create an audio element and store it globally
                    const audio = new Audio();
                    window.currentTTSAudio = audio;
                    
                    // Create blob URL
                    const blobUrl = URL.createObjectURL(blob);
                    audio.src = blobUrl;
                    
                    // Set up event handlers
                    audio.onended = function() {
                        console.log("TTS audio playback finished naturally");
                        // Revoke the blob URL to free memory
                        URL.revokeObjectURL(blobUrl);
                        window.currentTTSAudio = null;
                        handleTtsFinished();
                        resolve();
                    };
                    
                    audio.onerror = function(e) {
                        console.error("TTS audio playback error:", e);
                        URL.revokeObjectURL(blobUrl);
                        window.currentTTSAudio = null;
                        handleTtsFinished();
                        reject(e);
                    };
                    
                    // Play the audio
                    return audio.play()
                        .then(() => {
                            console.log("TTS audio playing");
                        })
                        .catch(error => {
                            console.error("Error playing TTS audio:", error);
                            URL.revokeObjectURL(blobUrl);
                            window.currentTTSAudio = null;
                            handleTtsFinished();
                            reject(error);
                        });
                })
                .catch(error => {
                    // Ignore abort errors
                    if (error.name === 'AbortError') {
                        console.log("TTS request was cancelled");
                        resolve();
                        return;
                    }
                    
                    console.error("Error with TTS:", error);
                    handleTtsFinished();
                    reject(error);
                });
            });
        }
        
        // Handle TTS playback finished
        function handleTtsFinished() {
            console.log("TTS playback finished");
            
            // Reset speaking flag
            window.isSpeaking = false;
            
            // Update UI
            const visualizerActive = document.getElementById('visualizer-active');
            const visualizerInactive = document.getElementById('visualizer-inactive');
            
            if (visualizerActive && visualizerInactive) {
                visualizerActive.classList.add('d-none');
                visualizerInactive.classList.remove('d-none');
            }
            
            // Update mic status if it exists
            const micStatus = document.getElementById('mic-status');
            if (micStatus) {
                micStatus.textContent = 'Listening...';
            }
            
            // Restart speech recognition with a slight delay to ensure everything is reset
            setTimeout(() => {
                setupSpeechRecognition();
            }, 300);
        }
        
        // Enhanced poll for messages function with better retry logic
        function pollForMessages() {
            // Get the current message count
            const messagesContainer = document.getElementById('chat-messages');
            const initialCount = messagesContainer.children.length;
            
            // Get all seen message IDs to prevent duplicates
            const seenMessageIds = new Set();
            const messageElements = messagesContainer.querySelectorAll('.message');
            messageElements.forEach(el => {
                const id = el.getAttribute('data-message-id');
                if (id) seenMessageIds.add(id);
            });
            
            console.log(`Starting polling with ${seenMessageIds.size} known messages`);
            
            // Create a polling function with exponential backoff
            let polling = true;
            let attempts = 0;
            let delay = 1000; // Start with 1s delay
            const maxDelay = 5000; // Max 5s delay
            const maxAttempts = 20; // Max 20 attempts
            
            function checkForNewMessages() {
                if (!polling || attempts >= maxAttempts) {
                    console.log("Polling stopped after max attempts");
                    return;
                }
                
                attempts++;
                console.log(`Polling attempt ${attempts}/${maxAttempts}`);
                
                fetch(`/api/session/${sessionId}/messages`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (!data.success) {
                            console.error("API error:", data.error || "Unknown error");
                            throw new Error(data.error || "Unknown error");
                        }
                        
                        if (data.messages && data.messages.length > 0) {
                            // Find new messages we haven't seen yet
                            const newMessages = data.messages.filter(message => 
                                message.id && !seenMessageIds.has(message.id)
                            );
                            
                            if (newMessages.length > 0) {
                                console.log(`Found ${newMessages.length} new messages`);
                                
                                // Look for new assistant messages
                                const newAssistantMessages = newMessages.filter(m => m.role === 'assistant');
                                if (newAssistantMessages.length > 0) {
                                    console.log(`Found ${newAssistantMessages.length} new assistant messages`);
                                    
                                    // Update seen messages
                                    newMessages.forEach(msg => {
                                        if (msg.id) seenMessageIds.add(msg.id);
                                    });
                                    
                                    // Add new messages to the UI
                                    newAssistantMessages.forEach(message => {
                                        updateConversation('assistant', message.content, message.id);
                                    });
                                    
                                    // Play TTS for the last message
                                    const lastMessage = newAssistantMessages[newAssistantMessages.length - 1];
                                    playTTS(lastMessage.content)
                                        .catch(error => {
                                            console.error("TTS error:", error);
                                            startSpeechRecognition();
                                        });
                                    
                                    // Stop polling now that we have an answer
                                    polling = false;
                                    return;
                                }
                            }
                        }
                        
                        // Continue polling with backoff if we didn't get anything
                        if (polling) {
                            // Exponential backoff with max
                            delay = Math.min(delay * 1.5, maxDelay);
                            setTimeout(checkForNewMessages, delay);
                        }
                    })
                    .catch(error => {
                        console.error("Error polling for messages:", error);
                        
                        // Try again with increased delay
                        if (polling) {
                            delay = Math.min(delay * 2, maxDelay);
                            setTimeout(checkForNewMessages, delay);
                        }
                    });
            }
            
            // Start polling
            checkForNewMessages();
        }
        
        // Setup WebSocket connection for monitoring
        function setupWebSocket() {
            console.log("Setting up WebSocket connection for monitoring");
            
            try {
                // Skip if monitoring WebSocket isn't needed
                if (!window.location.href.includes('remote=true')) {
                    console.log("Not a remote session, skipping WebSocket setup");
                    return;
                }
                
                // First try to locate if socket.io is already loaded
                if (typeof io === 'undefined') {
                    console.log("Socket.IO not available, loading it now");
                    
                    // Try CDN directly to avoid 400 errors from server path
                    const script = document.createElement('script');
                    script.src = 'https://cdn.socket.io/4.6.0/socket.io.min.js';
                    script.integrity = 'sha384-c79GN5VsunZvi+Q/WObgk2in0CbZsHnjEqvFxC5DxHn9lTfNce2WW6h2pH6u/kF+';
                    script.crossOrigin = 'anonymous';
                    
                    script.onload = function() {
                        console.log("Socket.IO loaded from CDN successfully");
                        initializeSocketConnection();
                    };
                    
                    script.onerror = function() {
                        console.error("Failed to load Socket.IO from CDN");
                        // Fall back to a simpler version if the integrity check fails
                        const fallbackScript = document.createElement('script');
                        fallbackScript.src = 'https://cdn.socket.io/socket.io-3.0.5.js';
                        fallbackScript.crossOrigin = 'anonymous';
                        
                        fallbackScript.onload = initializeSocketConnection;
                        document.head.appendChild(fallbackScript);
                    };
                    
                    document.head.appendChild(script);
                } else {
                    console.log("Socket.IO already available");
                    initializeSocketConnection();
                }
            } catch (error) {
                console.error("Error setting up WebSocket:", error);
            }
        }
        
        // Initialize Socket.IO connection
        function initializeSocketConnection() {
            if (typeof io === 'undefined') {
                console.error("Socket.IO library not loaded");
                return;
            }
            
            try {
                // Only create one socket connection
                if (!window.socket) {
                    console.log("Creating socket connection");
                    
                    // Set connection options
                    const options = {
                        reconnection: true,
                        reconnectionAttempts: 5,
                        reconnectionDelay: 1000,
                        transports: ['websocket', 'polling'] // Prefer WebSocket
                    };
                    
                    // Connect using current host
                    window.socket = io(window.location.origin, options);
                    
                    // Set up socket event handlers
                    window.socket.on('connect', function() {
                        console.log('Socket connected successfully');
                        
                        // Join the monitoring room for this session
                        window.socket.emit('join', { session_id: sessionId });
                        
                        // Send a test message
                        emitMessageViaSocket('Socket connection established', 'system');
                    });
                    
                    window.socket.on('connect_error', function(error) {
                        console.error('Socket connection error:', error);
                    });
                    
                    window.socket.on('disconnect', function() {
                        console.log('Socket disconnected');
                    });
                    
                    window.socket.on('message', function(data) {
                        console.log('Received message via socket:', data);
                    });
                } else {
                    console.log("Socket connection already exists");
                    
                    // Make sure we're connected
                    if (!window.socket.connected) {
                        console.log("Reconnecting existing socket");
                        window.socket.connect();
                    }
                }
            } catch (error) {
                console.error("Error initializing socket connection:", error);
            }
        }
        
        // Emit message via WebSocket for monitoring
        function emitMessageViaSocket(message, role) {
            if (!window.socket) {
                console.log("Socket not initialized, can't emit message");
                return;
            }
            
            if (!window.socket.connected) {
                console.log("Socket not connected, attempting to reconnect");
                window.socket.connect();
                
                // Try again after connection attempt
                setTimeout(() => {
                    if (window.socket.connected) {
                        emitMessageViaSocket(message, role);
                    } else {
                        console.log("Socket reconnection failed, message not sent");
                    }
                }, 1000);
                return;
            }
            
            try {
                console.log(`Emitting ${role} message to monitoring via socket`);
                window.socket.emit('message', {
                    session_id: sessionId,
                    role: role,
                    content: message,
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                console.error("Error emitting message via socket:", error);
            }
        }
    </script>
</body>
</html> 